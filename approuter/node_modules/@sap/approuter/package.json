{
  "_args": [
    [
      "@sap/approuter@2.7.1",
      "/Users/i048564/Documents/Eclipse/neon/sample.hello/approuter"
    ]
  ],
  "_from": "@sap/approuter@2.7.1",
  "_id": "@sap/approuter@2.7.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/@sap/approuter",
  "_nodeVersion": "6.9.2",
  "_npmUser": {
    "email": "do.not.reply@sap.com",
    "name": "https-support.sap.com"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "name": "@sap/approuter",
    "raw": "@sap/approuter@2.7.1",
    "rawSpec": "2.7.1",
    "scope": "@sap",
    "spec": "2.7.1",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://npm.sap.com/@sap/approuter/-/approuter-2.7.1.tgz",
  "_shasum": "a044445b50fee08f987c5b985e263c6b66f4e948",
  "_shrinkwrap": null,
  "_spec": "@sap/approuter@2.7.1",
  "_where": "/Users/i048564/Documents/Eclipse/neon/sample.hello/approuter",
  "dependencies": {
    "@sap/audit-logging": "^1.0.5",
    "@sap/e2e-trace": "^1.1.2",
    "@sap/logging": "^2.2.0",
    "@sap/xsenv": "^1.2.6",
    "agentkeepalive": "2.0.5",
    "async": "2.0.1",
    "basic-auth": "1.0.3",
    "commander": "2.9.0",
    "compression": "1.6.0",
    "connect": "3.4.1",
    "cookie": "0.2.2",
    "cookie-parser": "1.3.5",
    "cookie-signature": "1.0.6",
    "csrf": "3.0.0",
    "express-session": "1.15.0",
    "http-proxy-agent": "1.0.0",
    "https-proxy-agent": "1.0.0",
    "jwt-decode": "2.0.1",
    "lodash": "4.13.1",
    "lru-cache": "4.0.0",
    "mustache": "2.2.1",
    "passport": "0.3.2",
    "request": "2.79.0",
    "request-stats": "2.0.1",
    "safe-regex": "1.1.0",
    "send": "0.14.1",
    "serve-static": "1.11.1",
    "tough-cookie": "2.3.1",
    "tv4": "1.2.7",
    "urijs": "1.16.1",
    "verror": "1.6.0",
    "ws": "1.1.1"
  },
  "description": "Node.js based application router",
  "devDependencies": {
    "body-parser": "1.15.2",
    "chai": "3.5.0",
    "diveSync": "0.3.0",
    "eslint": "3.2.2",
    "filter-node-package": "^2.0.0",
    "istanbul": "0.4.4",
    "mocha": "3.0.2",
    "node-build": "^1.0.0",
    "node-mocks-http": "1.5.2",
    "node-style": "^2.0.0",
    "proxyquire": "1.7.10",
    "rimraf": "2.5.4",
    "sinon": "1.17.5",
    "supertest": "2.0.0"
  },
  "dist": {
    "shasum": "a044445b50fee08f987c5b985e263c6b66f4e948",
    "tarball": "https://npm.sap.com/@sap/approuter/-/approuter-2.7.1.tgz"
  },
  "engines": {
    "node": "^0.12.7 || ^4.4.0 || ^6.0.0"
  },
  "license": "SEE LICENSE IN developer-license-3.1.txt",
  "main": "approuter.js",
  "maintainers": [
    {
      "name": "https-support.sap.com",
      "email": "do.not.reply@sap.com"
    }
  ],
  "name": "@sap/approuter",
  "optionalDependencies": {},
  "readme": "# @sap/approuter\n\n\n## Overview\n\nWhen a business application consists of several different apps (microservices),\nthe application router is used to provide a single entry point to that business application.\nIt has the responsibility to:\n\n* Dispatch requests to backend microservices (reverse proxy)\n* Authenticate users\n* Serve static content\n\n\n![Application router overview diagram](doc/app-router-diagram.png \"Overview diagram\")\n\n\nLet's think of the different apps (microservices) as _destinations_ to which the incoming request will be forwarded.\nThe rules that determine which request should be forwarded to which destination are called _routes_.\nFor every destination there can be more than one route. You may read more on the concept of [routes](#routes) later in this document.\nIf the backend microservices require authentication, the application router can be configured to authenticate the users and propagate the user information.\nAgain by using routes, the application router can serve static content.\n\nThe application router is designed to work in XS Advanced - Cloud Foundry and XS OnPremise Runtime.\n\n**Note** that the application router does not hide the backend microservices in any way. They are still directly accessible bypassing the application router. So the backend microservices _must_ protect all their endpoints by validating the JWT token and implementing proper scope checks. Network isolation is not provided currently by the platform.\n\n## Deploying a business application with microservices\n\nFor example we can have a business application that has the following structure:\n\n<pre>\n+-- manifest.yml\n+-- manifest-op.yml\n|  +-- microservice-1\n|  | +-- ...\n|  | +-- ...\n|  +-- microservice-2\n|  | +-- ...\n|  | +-- ...\n|  +-- web\n|  | +-- ...\n|  | +-- ...\n</pre>\n\nThe *manifest.yml* file is used to deploy the business application on Cloud Foundry and the *manifest-op.yml* - on the XS OnPremise Runtime.\nThese files should describe all the microservices for that business application.\n\nFolders are used to isolate the different microservices. Let's assume that the application router is the microservice in the *web* folder (every business application has its own application router).\nHere is how we can include the application router:\n\n* Manually create the *node_modules* folder in the *web* folder.\n* Copy and paste the folder that contains the self-contained application router into *node_modules*. In this example the name of that folder is *@sap/approuter*, see the *start* script in the *package.json* below.\n* Check the version of the application router you just copied.\n* Create a *package.json* file in *web* with content similar to the following and replace the version's value with the version of your application router:\n\n```json\n{\n    \"name\": \"hello-world-approuter\",\n    \"dependencies\": {\n       \"@sap/approuter\": \"2.6.1\"\n    },\n    \"scripts\": {\n        \"start\": \"node node_modules/@sap/approuter/approuter.js\"\n    }\n}\n```\n\nIn order to use the application router you don't have to write any JavaScript code.\nOnly some configurations have to be provided in the *web* folder. Here is a complete example:\n\n<pre>\n+-- web\n| +-- package.json\n| +-- xs-app.json\n| +-- resources\n| | +-- hello-world.html\n| | +-- my-page.html\n| +-- node_modules\n| |   +-- ...\n| +-- default-env.json\n| +-- default-services.json\n</pre>\n\nThe *web* folder contains the *package.json*, *node_modules*, some configuration files used by the application router, and static resources to be served.\nYou can read more about the [configurations](#configurations) later in this document.\n\nBy default, the application router runs on port 5000 (if started locally) or it takes the port from the `PORT` environment variable.\n\n## Working directory\n\nThe working directory contains configuration files that the application router needs and static resources that can be served at runtime.\nIn the [previous example](#deploying-a-business-application-with-microservices), the *web* folder is the working directory.\nBy default the current directory is the working directory.\nIt is possible to configure it during start up of the application router with the following command line argument:\n\n```bash\nnode approuter.js -w <working-dir>\n```\n\nApplication router will abort if the working directory does not contain *xs-app.json* file.\n\n## Configurations\n\nThe application router makes use of the following configurations:\n\n- [Main configuration](#xs-appjson-configuration-file) - this is the *xs-app.json* file. This file is mandatory and contains the main configurations of the application router.\n\n- [UAA configuration](#uaa-configuration) - the application router reads this configuration either from the `VCAP_SERVICES` environment variable (when deployed on Cloud Foundry or XS Advanced OnPremise Runtime)\nor from the *default-services.json* file (when running locally). Refer to the documentation of the `@sap/xsenv` package for more details.\n\n- Configurations from the environment - these configurations are either read from the application router's environment (when deployed on Cloud Foundry or XS Advanced OnPremise Runtime)\nor from the *default-env.json* file (when running locally). Refer to the documentation of the `@sap/xsenv` package for more details.\nThe environment variables that the application router takes into account are:\n\n\nConfiguration | Environment variable | Description\n------------- | -------------------- | ------------\n[UAA service name](#uaa-configuration) | `UAA_SERVICE_NAME` | Contains the name of the UAA service to be used.\n[Destinations](#destinations) | `destinations` | Provides information about the available destinations.\n[Additional headers](#additional-headers-configuration) | `httpHeaders` | Provides headers that the application router will return to the client in its responses.\n[Plugins](#plugins-configuration) | `plugins` | A plugin is just like a [*route*](#routes) except that you can't configure some inner properties.\n[Session timeout](#session-timeout) | `SESSION_TIMEOUT` | Positive integer representing the session timeout in minutes. The default timeout is 15 minutes.\n[X-Frame-Options](#x-frame-options-configuration) | `SEND_XFRAMEOPTIONS`, `httpHeaders` | Configuration for the X-Frame-Options header value.\n[Clickjack whitelist service](#whitelist-service) | `CJ_PROTECT_WHITELIST` | Configuration for the whitelist service preventing clickjack attacks.\n[Web Sockets origins whitelist](#web-sockets) | `WS_ALLOWED_ORIGINS` | Whitelist configuration used for verifying the `Origin` header of the initial upgrade request when establishing a web socket connection.\nJWT Token refresh | `JWT_REFRESH` | The time in minutes before a JWT token expires and the application router should trigger a token refresh routine.\nIncoming connection timeout | `INCOMING_CONNECTION_TIMEOUT` | Maximum time in milliseconds for a client connection. After that time the connection is closed. If set to 0, the timeout is disabled. Default: 120000 (2 min)\nTenant host pattern | `TENANT_HOST_PATTERN` | String containig a regular expression with a capturing group. The request host is matched against this regular expression. The value of the first capturing group is used as tenant id.\n[Compression](#compression-property) | `COMPRESSION` | Configuration regarding compressing resources before responding to the client.\n_Secure_ flag of session cookie | `SECURE_SESSION_COOKIE` | Can be set to `true` or `false`. By default, the _Secure_ flag of the session cookie is set depending on the environment the application router runs in. For example, when application router is behind a router (Cloud Foundry's router or SAP Web Dispatcher) that is configured to serve HTTPS traffic, then this flag will be present. During local development the flag is not set. This environment variable can be used to enforce setting or omitting the _Secure_ flag. **Note**: If the Secure flag is enforced, the application router will reject requests sent over unencrypted connection (http).\nTrusted CA certificates | `XS_CACERT_PATH` | List of files paths with trusted CA certificates used for outbound https connections (UAA, destinations, etc.). File paths are separated by [path.delimiter](https://nodejs.org/api/path.html#path_path_delimiter). If this is omitted, several well known \"root\" CAs (like VeriSign) will be used. This variable is set automatically by XSA On-premise runtime.\n\n**Note:** all those environment variables are optional.\n\n\n### Destinations\n\nThe destinations configuration is provided in the `destinations` environment variable.\n\nThere has to be a destination for every single app (microservice) that is a part of the business application.\nThe destinations configuration is an array of objects. Here are the properties that a destination can have:\n\nProperty | Type | Optional | Description\n-------- | ---- |:--------:| -----------\nname | String | | Unique identifier of the destination.\nurl | String | | URL of the app (microservice).\nproxyHost | String | x | The host of the proxy server used in case the request should go through a proxy to reach the destination.\nproxyPort | String | x | The port of the proxy server used in case the request should go through a proxy to reach the destination.\nforwardAuthToken | Boolean | x | If `true` the OAuth token will be sent to the destination. The default value is `false`. This token contains user identity, scopes and other attributes. It is signed by the UAA so it can be used for user authentication and authorization with backend services.\nstrictSSL | Boolean | x | Configures whether the application router should reject untrusted certificates. The default value is `true`.\ntimeout | Number | x | Positive integer representing the maximum wait time for a response (in milliseconds) from the destination. Default is 30000ms.\n\n**Note:** The timeout specified will also apply to the [destination's logout path](#destinations-property) (if you have set one). <br />\n**Note:** `proxyHost` and `proxyPort` are optional, but if one of them is defined, then the other one becomes mandatory.\n\nSample content of the destinations environment variable:\n\n```json\n[\n  {\n    \"name\" : \"ui5\",\n    \"url\" : \"https://sapui5.netweaver.ondemand.com\",\n    \"proxyHost\" : \"proxy\",\n    \"proxyPort\" : \"8080\",\n    \"forwardAuthToken\" : false,\n    \"timeout\" : 1200\n  }\n]\n```\n\nIt is also possible to include the destinations in the *manifest.yml* and *manifest-op.yml* files:\n\n```yml\n- name: node-hello-world\n  memory: 100M\n  path: web\n  env:\n    destinations: >\n                  [\n                    {\"name\":\"ui5\", \"url\":\"https://sapui5.netweaver.ondemand.com\"}\n                  ]\n```\n\n\n### UAA configuration\n\nThe User Account and Authentication (UAA) server is responsible for user authentication.\nIn Cloud Foundry and XS OnPremise Runtime a service is created for this configuration and by using the standard service binding mechanism\nthe content of this configuration is available in the `VCAP_SERVICES` environment variable.</br>\n**Note:** The service should have `xsuaa` in its tags or the environment variable `UAA_SERVICE_NAME` should be specified (stating the exact name of the UAA service).</br>\nDuring local development the UAA configuration is provided in the *default-services.json* file.\nWhen the UAA is used for authentication the user is redirected to the UAA's login page to enter their credentials.\n\nSample content for a *default-services.json* file:\n\n```json\n{\n    \"uaa\": {\n        \"url\" : \"http://my.uaa.server/\",\n        \"clientid\" : \"client-id\",\n        \"clientsecret\" : \"client-secret\",\n        \"xsappname\" : \"my-business-application\"\n    }\n}\n```\n\nThe application router supports the `$XSAPPNAME` placeholder (upper case letters). You may use it in your [route](#routes) configurations in the scope property.\nThe value of `$XSAPPNAME` is taken from the UAA configuration (the `xsappname` property).\n\n### Additional headers configuration\n\nIf configured, the application router can send additional http headers in its responses to the client.\nAdditional headers can be set in the `httpHeaders` environment variable.\n\nSample configuration for additional headers:\n\n```json\n[\n  {\n    \"X-Frame-Options\": \"ALLOW-FROM http://localhost\"\n  },\n  {\n    \"Test-Additional-Header\": \"1\"\n  }\n]\n```\nIn this case the application router will send two additional headers in the responses to the client.\n\n### Plugins configuration\n\nA plugin serves almost the same purpose as [*routes*](#routes). The difference is that plugins can be configured through the environment and that way you can add new routes to the application router without changing the design-time artefact *xs-app.json*. The plugin configuration properties are the same as those of a [*route*](#routes) except that you can't configure `localDir`, `replace` and `cacheControl`.\n\nProperty | Type | Optional | Description\n-------- | ---- |:--------:| -----------\nname | String | | The name of this plugin\nsource | String/Object | | The purpose of this property is to describe a regular expression that matches the incoming request path.</br> **Note:** A request matches a particular route if its path __contains__ the given pattern. To ensure the RegExp matches the complete path, surround it with `^` and `$`.\ntarget | String | x | Defines how the incoming request path will be rewritten for the corresponding destination.\ndestination | String | | The name of the destination to which the incoming request should be forwarded.\nauthenticationType | String | x | The value can be `xsuaa`, `basic` or `none`. The default one is `xsuaa`. When `xsuaa` is used the specified UAA server will handle the authentication (the user is redirected to the UAA's login form). The `basic` mechanism works with SAP HANA users. If `none` is used then no authentication is needed for this route.\ncsrfProtection | Boolean | x | Enable [CSRF protection](#csrf-protection) for this route. The default value is `true`.\nscope | Array/String/Object | x | Scopes are related to the permissions a user needs to access a resource. This property holds the required scopes to access the target path. Access is granted if the user has at least one of the listed scopes.\n\nSample content of the `plugins` environment variable:\n```json\n[\n  {\n    \"name\": \"insecurePlugin\",\n    \"source\": \"/plugin\",\n    \"destination\": \"plugin\",\n    \"target\": \"/\",\n    \"csrfProtection\": false,\n    \"scope\": [\"viewer\", \"reader\"]\n  },\n  {\n    \"name\": \"publicPlugin\",\n    \"source\": \"/public-plugin\",\n    \"destination\": \"publicPlugin\",\n    \"authenticationType\": \"none\"\n  }\n]\n```\n\n### Session timeout\n\nFor example, if you have the following line in your *manifest.yml* or *manifest-op.yml* file:\n\n```yml\n- name: node-hello-world\n  memory: 100M\n  path: web\n  env:\n    SESSION_TIMEOUT: 40\n```\n\nAfter 40 minutes of user inactivity (no requests have been sent to the application router), a Central Logout will be triggered due to session timeout.\n\n**Note:** The application router depends on the UAA server for user authentication, if the `authenticationType` for a route is `xsuaa`. The UAA server may have a different session timeout configured.\nIt is recommended that the configurations of the application router and the UAA are identical.<br />\n\n### X-Frame-Options configuration\n\nApplication router sends `X-Frame-Options` header by default with value `SAMEORIGIN`. This behaviour can be changed in 2 ways:\n\n- Disable sending the default header value by setting `SEND_XFRAMEOPTIONS` environment variable to `false`\n- Override the value to be sent via [additional headers configuration](#additional-headers-configuration)\n\n## Routes\n\nA route is a configuration that instructs the application router how to process an incoming request with a specific path.\n\nProperty | Type | Optional | Description\n-------- | ---- |:--------:| -----------\nsource | String/Object | | The purpose of this property is to describe a regular expression that matches the incoming request path.</br> **Note:** A request matches a particular route if its path __contains__ the given pattern. To ensure the RegExp matches the complete path, surround it with `^` and `$`.\nhttpMethods | Array of upper-case HTTP methods | x | Which HTTP methods will be served by this route; the methods supported are: `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE`, `PATCH` (no extension methods are supported). If this option is not specified, the route will serve any HTTP method.\ntarget | String | x | Defines how the incoming request path will be rewritten for the corresponding destination or static resource.\ndestination | String | x | The name of the destination to which the incoming request should be forwarded.\nlocalDir | String | x | Folder in the [working directory](#working-directory) from which the application router will serve static content **Note:** localDir routes support only HEAD and GET requests; requests with any other method receive a 405 Method Not Allowed.\nreplace | Object | x | An object that contains the configuration for replacing placeholders with values from the environment. *It is only relevant for static resources*. Its structure is described in [Replacements](#replacements).\nauthenticationType | String | x | The value can be `xsuaa`, `basic` or `none`. The default one is `xsuaa`. When `xsuaa` is used the specified UAA server will handle the authentication (the user is redirected to the UAA's login form). The `basic` mechanism works with SAP HANA users. If `none` is used then no authentication is needed for this route.\ncsrfProtection | Boolean | x | Enable [CSRF protection](#csrf-protection) for this route. The default value is `true`.\nscope | Array/String/Object | x | Scopes are related to the permissions a user needs to access a resource. This property holds the required scopes to access the target path.\ncacheControl | String | x | String representing the value of the `Cache-Control` header, which is set on the response when serving static resources. By default the `Cache-Control` header is not set. *It is only relevant for static resources.*\n\n\n**Note:** The properties `destination` and `localDir` are both optional, but exactly one of them must be defined. <br />\n**Note:** When using the properties `replace` or `cacheControl` it is mandatory to define the `localDir` property.\n\n### Example routes\n\nFor example, if you have a configuration with the following destination:\n\n```json\n[\n  {\n    \"name\" : \"app-1\",\n    \"url\" : \"http://localhost:3001\"\n  }\n]\n```\n\nHere are some sample route configurations:\n\n* Route with a `destination` and no `target`\n\n```json\n{\n    \"source\": \"^/app1/(.*)$\",\n    \"destination\": \"app-1\"\n}\n```\n\nSince there is no `target` property for that route, no path rewriting will take place.\nIf we receive */app1/a/b* as a path, then a request to *http://localhost:3001/app1/a/b* is sent.\nThe source path is appended to the destination URL.\n\n* Route with case-insensitive matching\n\n```json\n{\n    \"source\": {\n      \"path\": \"^/app1/(.*)$\",\n      \"matchCase\": false\n    },\n    \"destination\": \"app-1\"\n}\n```\n\nThis example is much like the previous one,\nbut instead of accepting only paths starting with */app1/*, we accept any variation of _app1_'s case. </br>\nThat means if we receive */ApP1/a/B*, then a request to *http://localhost:3001/ApP1/a/B* is sent. </br>\n**Note:** The property `matchCase` has to be of type boolean. It is optional and has a default value `true`.\n\n* Route with a `destination` and a `target`\n\n```json\n{\n    \"source\": \"^/app1/(.*)$\",\n    \"target\": \"/before/$1/after\",\n    \"destination\": \"app-1\"\n}\n```\n\nWhen a request with path */app1/a/b* is received, the path rewriting is done according to the rules in the `target` property.\nThe request will be forwarded to http://localhost:3001/before/a/b/after.\n\n**Note:** In regular expressions there is the term _capturing group_. If a part of a regular expression is surrounded with parenthesis, then what has been matched can be accessed using _$_ + the number of the group (starting from 1).\nIn the last example _$1_ is mapped to the _(.*)_ part of the regular expression in the `source` property.\n\n* Route with a `localDir` and no `target`\n\n```json\n{\n    \"source\": \"^/web-pages/(.*)$\",\n    \"localDir\": \"my-static-resources\"\n}\n```\n\nSince there is no `target` property for that route, no path rewriting will take place.\nIf we receive a request with a path */web-pages/welcome-page.html*, the local file at *my-static-resources/web-pages/welcome-page.html*\nunder the working directory will be served.\n\n* Route with a `localDir` and a `target`\n\n```json\n{\n    \"source\": \"^/web-pages/(.*)$\",\n    \"target\": \"$1\",\n    \"localDir\": \"my-static-resources\"\n}\n```\nIf we receive a request with a path '/web-pages/welcome-page.html', the local file at 'my-static-resources/welcome-page.html'\nunder the working directory will be served.</br> **Note:** The capturing group used in the `target` property.\n\n* Route with `localDir` and `cacheControl`\n\n```json\n{\n  \"source\": \"^/web-pages/\",\n  \"localDir\": \"my-static-resources\",\n  \"cacheControl\": \"public, max-age=1000,must-revalidate\"\n}\n```\n\n* Route with `httpMethods` restrictions\n\nThe `httpMethods` option allows you to split the same path across different targets depending on the HTTP method. For example:\n\n```json\n{\n  \"source\": \"^/app1/(.*)$\",\n  \"target\": \"/before/$1/after\",\n  \"httpMethods\": [\"GET\", \"POST\"]\n}\n```\n\nThis route will be able to serve only GET and POST requests. Any other method (including extension ones) will get a 405 Method Not Allowed response. The same endpoint can be split across multiple *destinations* depending on the HTTP method of the requests:\n\n```json\n{\n  \"source\": \"^/app1/(.*)$\",\n  \"destination\" : \"dest-1\",\n  \"httpMethods\": [\"GET\"]\n},\n{\n  \"source\": \"^/app1/(.*)$\",\n  \"destination\" : \"dest-2\",\n  \"httpMethods\": [\"DELETE\", \"POST\", \"PUT\"]\n}\n```\n\nThe setup above will route GET requests to the target *dest-1*, DELETE, POST and PUT to *dest-2*, and any other method receives a 405. It is also possible to specify \"catchAll\" routes, namely those that do not specify `httpMethods` restrictions:\n\n```json\n{\n  \"source\": \"^/app1/(.*)$\",\n  \"destination\" : \"dest-1\",\n  \"httpMethods\": [\"GET\"]\n},\n{\n  \"source\": \"^/app1/(.*)$\",\n  \"destination\" : \"dest-2\"\n}\n```\n\nIn the setup above, GET requests will be routed to *dest-1*, and all the rest to *dest-2*.\n\nWhy using `httpMethods`? It is often useful to split the implementation of microservices across multiple, highly specialized applications. For example, a Java application written to serve high amounts of GET requests that return large payloads is implemented, sized, scaled and load-tested differently than applications that offer APIs to upload limited amounts of data. `httpMethods` allows you to split your REST APIs, e.g., */Things* to different applications depending on the HTTP methods of the requests, without having to make the difference visible in the URL of the endpoints.\n\nAnother usecase for `httpMethods` is to \"disable\" parts of the REST API. For example, it may be necessary to disable some endpoints that accept DELETE for external usage. By whitelisting in the relative route only the allow methods, you can hide functionalities of your microservice that should not be consumable without having to modify the code or configurations of your service.\n\n**Note:** `localDir` and `httpMethods` are incompatible. The following route is invalid:\n\n```json\n{\n  \"source\": \"^/app1/(.*)$\",\n  \"target\": \"/before/$1/after\",\n  \"localDir\": \"resources\",\n  \"httpMethods\": [\"GET\", \"POST\"]\n}\n```\n\nHowever, since `localDir` supports only GET and HEAD requests, returning 405 to requests with any other method, any `localDir` route is \"implicitly\" restricted in terms of supported HTTP methods.\n\n* Route with a `scope`\n\nAn application specific scope has the following format:\n\n```\n<application-name>.<scope-name>\n```\n\nIt is possible to configure what scope the user needs to possess in order to access a specific resource. Those configurations are per [route](#routes).\n\nIn this example, the user should have **at least** one of the scopes in order to access the corresponding resource.\n\n```json\n{\n    \"source\": \"^/web-pages/(.*)$\",\n    \"target\": \"$1\",\n    \"scope\": [\"$XSAPPNAME.viewer\", \"$XSAPPNAME.reader\", \"$XSAPPNAME.writer\"]\n}\n```\n\nFor convenience if our route requires only one scope the `scope` property can be a string instead of an array. The following configuration is valid as well:\n\n```json\n{\n    \"source\": \"^/web-pages/(.*)$\",\n    \"target\": \"$1\",\n    \"scope\": \"$XSAPPNAME.viewer\"\n}\n```\n\nYou can configure scopes for the different HTTP methods (GET, POST, PUT, HEAD, DELETE, CONNECT, TRACE, PATCH and OPTIONS). If some of the HTTP methods are not explicitly set, the behaviour for them is defined by the `default` property. In case there is no `default` property specified and the HTTP method is also not specified, the request is rejected by default.\n\n```json\n{\n    \"source\": \"^/web-pages/(.*)$\",\n    \"target\": \"$1\",\n    \"scope\": {\n      \"GET\": \"$XSAPPNAME.viewer\",\n      \"POST\": [\"$XSAPPNAME.reader\", \"$XSAPPNAME.writer\"],\n      \"default\": \"$XSAPPNAME.guest\"\n    }\n}\n```\n\nThe application router supports the `$XSAPPNAME` placeholder. Its value is taken (and then substituted in the routes) from the UAA configuration.\nYou may read more about it [here](#uaa-configuration). </br>**Note:** The substitution is case sensitive.\n\nYou can use the name of the business application directly instead of using the `$XSAPPNAME` placeholder:\n\n```json\n{\n    \"source\": \"^/backend/(.*)$\",\n    \"scope\": \"my-business-application.viewer\"\n}\n```\n\n## Replacements\n\nThis object configures the placeholder replacement in static text resources.\n\nProperty | Type | Description\n-------- | ---- | -----------\npathSuffixes | Array | An array containing the path suffixes that are relative to `localDir`. Only files with a path ending with any of these suffixes will be processed.\nvars | Array | A whitelist with the environment variables that will be replaced in the files matching the suffix.\nservices | Object | An object describing bound services that will provide replacement values. Each property of this object is used to lookup a separate service. The property names are arbitrary. Service lookup format is described in _Service Query_ section in _@sap/xsenv_ documentation.\n\nThe supported tags for replacing environment variables are: `{{ENV_VAR}}` and `{{{ENV_VAR}}}`.\nIf there is such an environment variable it will be replaced, otherwise it will be just an empty string.\n\nFor services you can specify a property from the `credentials` section of the service binding which will be replaced.\nFor example `{{{my_service.property}}}` and `{{my_service.property}}`\n\nEvery variable that is replaced using two-brackets syntax will be HTML-escaped.\n\nFor example if the value of the environment variable is `ab\"cd` the result will be `ab&amp;quot;cd`.</br>\nThe triple brackets syntax is used when the replaced values don't need to be escaped and all values will be unchanged.\n\nFor example, if somewhere in your *xs-app.json* you have a route:\n\n```json\n{\n  \"source\": \"^/get/home(.*)\",\n  \"target\": \"$1\",\n  \"localDir\": \"resources\",\n  \"replace\": {\n    \"pathSuffixes\": [\"index.html\"],\n    \"vars\": [\"escaped_text\", \"NOT_ESCAPED\"],\n    \"services\": {\n      \"my-sapui5-service\": {\n        \"tag\": \"ui5\"\n      }\n    }\n  }\n}\n```\n\nand you have the following `index.html`:\n\n```html\n<html>\n  <head>\n    <title>{{escaped_text}}</title>\n    <script src=\"{{{NOT_ESCAPED}}}/index.js\"/>\n    <script src=\"{{{my-sapui5-service.url}}}\"/>\n  </head>\n</html>\n```\nthen in `index.html`, `{{escaped_text}}` and `{{{NOT_ESCAPED}}}` will be replaced with the values of the environment variables `escaped_text` and `NOT_ESCAPED`.\n\nIf you have a service in VCAP_SERVICES like:\n\n```json\n{\n  \"sapui5_service\": [{\n    \"name\": \"sapui5\",\n    \"tags\": [\"ui5\"],\n    \"credentials\": {\n      \"url\": \"http://sapui5url\"\n    }\n  }]\n}\n```\nthen `{{{my-sapui5-service.url}}}` will be replaced with the `url` property from `sapui5` service - in this case `http://sapui5url`.\n\n**Note:** _All_ index.html files will be processed.\nIf you want to replace only specific files, you have to set the path of the file relative to `localDir`.\n\n**Note:** All files should be **UTF-8** encoded.\n\n**Note:** If a service is not found an error is thrown on startup.\n\n**Note:** If a service and an environment variable from `vars` have the same name, an error is thrown on startup.\n\nThe returned content type is based on the file extension. Currently the supported file extensions are:\n* .json - application/json\n* .txt - text/plain\n* .html - text/html\n* .js - application/javascript\n* .css - test/css\n\nIf the file extension is different, the default content type is `text/html`.\n\nExample for `pathSuffixes`:\n```json\n{\n  \"pathSuffixes\": [\".html\"]\n}\n```\nThe suffix `.html` means that all files with the extension *.html* under `localDir` and it's subfolders will be processed.\n```json\n{\n  \"pathSuffixes\": [\"/abc/main.html\", \"some.html\"]\n}\n```\nThe suffix `/abc/main.html` means that all files named *main.html* which are inside a folder named *abc* will be processed.\n\nThe suffix `some.html` means that all files which have a name that ends with *some.html* will be processed. For example: `some.html`, `awesome.html`.\n\n```json\n{\n  \"pathSuffixes\": [\"/some.html\"]\n}\n```\n\nThe suffix `/some.html` means that all files which have the **exact** name *some.html* will be processed. For example: `some.html`, `/abc/some.html`.\n\n**Note:** URL path parameters are not supported for replacements.\nFor example, replacements will not work if the path looks like '/test;color=red/index.html'. For more information regarding path parameters refer to [http://tools.ietf.org/html/rfc3986#section-3.3](http://tools.ietf.org/html/rfc3986#section-3.3).\n\n## _xs-app.json_ configuration file\n\nThis is the main configuration file of the application router.\n\n### Top Level Properties\n\nThe xs-app.json descriptor contains the following top level properties:\n\nProperty | Type | Optional | Description\n-------- | ---- |:--------:| -----------\n[welcomeFile](#welcomefile-property) | String | x | The client is redirected to this page by default, if the request does not have a path. For more information, see [welcomeFile](#welcomefile-property).\n[authenticationMethod](#authenticationmethod-property) | String | x | If set to `none` the UAA login roundtrip is disabled. If the property is not set and authentication is defined per [route](#routes), the value is set to `route` by default.\nsessionTimeout | Number | x | Used to set session timeout. The default is 15 minutes. If the [SESSION_TIMEOUT](#session-timeout) environment variable is set this property will be overwritten.\n[routes](#routes-property) | Array | x | Contains all route configurations. The position of a configuration in this array is of significance for the application router in case a path matches more than one *source*. The first route whose *source* matches the path of the incoming request gets activated.\n[login](#login-property) | Object | x | Contains the configuration for the endpoint of the application router which will be used by the UAA during the OAuth2 authentication routine. By default this endpoint is `/login/callback`.\n[logout](#logout-property) | Object | x | Provides options for a [Central Logout](#central-logout) endpoint and a page to which the client to be redirected by the UAA after logout.\n[destinations](#destinations-property) | Object | x | Additional options for your destinations (besides the ones in the `destinations` environment variable).\n[compression](#compression-property) | Object | x | Configuration regarding compressing resources before responding to the client. If the [COMPRESSION](#compression-property) environment variable is set it will overwrite existing values.\n[pluginMetadataEndpoint](#pluginmetadataendpoint-property) | String | x | Adds an endpoint that will serve a JSON representing all configured plugins.\n[whitelistService](#whitelistservice-property) | Object | x | Options for the whitelist service preventing clickjack attacks.\n[websockets](#websockets-property) | Object | x | Options for the [web socket communication](#web-sockets).\n[errorPage](#errorpage-property) | Array | x | Optional configuration to set-up a custom error pages whenever the approuter encouters an error.\n\n### _welcomeFile_ property\n\nApprouter will redirect to this URL when `/`(root path) is requested.\nThis could be a file located inside the static resources folder or a resource hosted at a different location.\n\n**Note:** Approuter will serve the content of the resource instead of returning a redirect if the request contains a `x-csrf-token: fetch` header.\nSee [CSRF Protection](#csrf-protection).\n\n\nExample:\n```json\n\"welcomeFile\": \"/web-pages/hello-world.html\"\n```\n\n`web-pages` has to be a part of a local resource or an external destination\n```json\n{\n    \"source\": \"^/web-pages/(.*)$\",\n    \"localDir\": \"my-static-resources\"\n}\n```\nor\n```json\n{\n    \"source\": \"^/web-pages/(.*)$\",\n    \"target\": \"$1\",\n    \"destination\": \"mydest\"\n}\n```\n\n\nNote: If there isn't a route with a localDir property, the folloing default is added to the list of routes:\n\n```json\n{\n  \"source\": \"^/(.*)$\",\n  \"localDir\": \"resources\"\n}\n```\n\n\n### _authenticationMethod_ property\n\nIt may have the following values:\n\n* `none` - disables authentication for all routes\n* `route` - authentication type is defined in the [route](#routes) configurations\n\nThe default value is `route`.\n\n### _routes_ property\n\nIt holds an array of route configuration objects. The order of the configurations is important for the application router.\nThe first route whose `source` pattern gets matched with the path of the incoming request will be activated.\nSee [Routes](#routes) for more info.\n\n### _login_ property\n\nA redirect to the application router at a specific endpoint takes place during OAuth2 authentication with UAA.\nThis endpoint can be configured in order to avoid possible collisions. For example:\n\n```json\n\"login\": {\n  \"callbackEndpoint\": \"/custom/login/callback\"\n}\n```\n\nThe default endpoint is `/login/callback`.\n\n### _logout_ property\n\nIn this object you can define your business application's central logout endpoint through the `logoutEndpoint` property.\nFor example, if somewhere in your *xs-app.json* you have:\n\n```json\n\"logout\": {\n  \"logoutEndpoint\": \"/my/logout\"\n}\n```\n\nThis will open an endpoint on application router which, when requested, will trigger the [central logout](#central-logout) routine.\nChanging the browser location from the client-side JavaScript code:\n\n```javascript\nwindow.location.replace('/my/logout');\n```\n\nwill trigger client initiated central Logout.\n\nIn addition, a page to which the user will be redirected by the UAA after logout can be configured using the `logoutPage` property.\nIt may hold:\n\n- URL path - the UAA will redirect the user back to the application router and the path will be interpreted according the configured [routes](#routes).\n\n**Note**: The resource that matches the path should not require authentication. The property `authenticationType` should be set to `none` for that particular route.\n\nExample:\n\n```json\n{\n  \"authenticationMethod\": \"route\",\n  \"logout\": {\n    \"logoutEndpoint\": \"/my/logout\",\n    \"logoutPage\": \"/logout-page.html\"\n  },\n  \"routes\": [\n    {\n      \"source\": \"^/logout-page.html$\",\n      \"localDir\": \"my-static-resources\",\n      \"authenticationType\": \"none\"\n    }\n  ]\n}\n```\n\nIn this case *my-static-resources* (contains *logout-page.html*) is a folder with static resources in the working directory of the application router.\n\n- Absolute http(s) URL - the UAA will redirect the user to a page (or application) different from the application router.\nFor example:\n\n```json\n\"logout\": {\n  \"logoutEndpoint\": \"/my/logout\",\n  \"logoutPage\": \"http://employees.portal\"\n}\n```\n\n**Limitation**: The `logoutPage` configuration can only be used in XS Advanced OnPremise Runtime.\n\n\n### _destinations_ property\n\nLet's say you have a destination called `node-backend`. You can specify options for it by adding the `destinations` property in your xs-app.json:\n```json\n\"destinations\": {\n  \"node-backend\": {}\n}\n```\nThe value of `node-backend` should be an object with the following properties:\n\nProperty | Type | Optional | Description\n-------- | ---- |:--------:| -----------\nlogoutPath | String | x | The logout endpoint for your destination.\nlogoutMethod | String | x | Could be POST, PUT, GET. The default value is POST.\n\nThe `logoutPath` will be called when [Central Logout](#central-logout) is triggered or a session is deleted due to timeout.\nThe request to the `logoutPath` will contain additional headers, including the JWT token.\nThe `logoutMethod` property specifies the HTTP method with which the `logoutPath` will be requested. For example:\n```json\n{\n  \"destinations\": {\n    \"node-backend\": {\n      \"logoutPath\": \"/ui5logout\",\n      \"logoutMethod\": \"GET\"\n    }\n  }\n}\n```\n\n### _compression_ property\nBy default text resources are compressed before being sent to the client.\nThe default threshold for using compression is 1K. Text resources under this size will not be compressed.\nIf you need to change the compression size threshold, you can add the optional property `minSize`.\n\nHere is an example of a compression section (2048 bytes):\n```json\n{\n  \"compression\": {\n      \"minSize\": 2048\n  }\n}\n```\n\nProperty | Type | Optional | Description\n-------- | ---- |:--------:| -----------\nminSize | Number | x | Text resources larger than this size will be compressed.\nenabled | Boolean | x | Globally disables or enables compression. Default value is true.\n\n**Note:** There are 3 ways to disable compression:\n* Global - within the compression section add ```\"enabled\": false```\n* Front-End - the client sends a header Accept-Encoding which omits gzip\n* Backend  - the application sends a header Cache-Control with the 'no-transform' directive\n\nExample of globally disabling compression using the environment variable `COMPRESSION`:\n```json\n{\n  \"enabled\": false\n}\n```\n\n**Note:** The header field `Content-Length` is used to determine the resource size.\nIf `Content-Length` is missing, the chunk size is used to determine whether to compress the resource.\nFor more information, see the npm module compression.\n\n### _pluginMetadataEndpoint_ property\n\nExample:\n```json\n{\n  \"pluginMetadataEndpoint\": \"/metadata\"\n}\n```\n\n**Note**: If you request relative path `/metadata` of your application, you will receive a JSON with configured plugins.\n\n### _whitelistService_ property\n\nEnabling the whitelist service is used for prevention of clickjack attacks.\nAn endpoint accepting GET requests will be opened at the relative path configured in the `endpoint` property.\nFor more details see [Whitelist service](#whitelist-service) section.\n\nExample:\n```json\n{\n  \"whitelistService\": {\n    \"endpoint\": \"/whitelist/service\"\n  }\n}\n```\n\n### _websockets_ property\n\nFor more details about the web socket communication see [Web sockets](#web-sockets) section.\n\nExample:\n```json\n{\n  \"websockets\": {\n    \"enabled\": true\n  }\n}\n```\n\n### _errorPage_ property\n\nBy default, errors originating in the application router are shown the [status code](https://nodejs.org/api/http.html#http_http_status_codes) of the error.\nIt is also possible to display a custom error page using the `errorPage` property.\n\nThe property is an array of objects, each object having the following properties:\n\nProperty | Type         | Optional | Description\n-------- | ------------ |:--------:| -----------\nstatus   | Number/Array |          | HTTP status code\nfile     | String       |          | File path relative to the working directory of the application router\n\n\nExample:\n```json\n{ \"errorPage\" : [\n    {\"status\": [400,401,402], \"file\": \"./custom-err-40x.html\"},\n    {\"status\": 501, \"file\": \"./http_resources/custom-err-501.html\"}\n  ]\n}\n```\nIn the example above 400, 401 and 402 errors would be shown the content of  `./custom-err-4xx.html` and for 501 errors the user would see `./http_resources/custom-err-501.html`.\n\n**Note:** The errorPage conifugration section has no effect on errors generated outside of the application router.\n\n### Complete example of an _xs-app.json_ configuration file:\n```json\n{\n  \"welcomeFile\": \"index.html\",\n  \"authenticationMethod\": \"route\",\n  \"sessionTimeout\": 10,\n  \"pluginMetadataEndpoint\": \"/metadata\",\n  \"routes\": [\n    {\n      \"source\": \"^/sap/ui5/1(.*)$\",\n      \"target\": \"$1\",\n      \"destination\": \"ui5\",\n      \"csrfProtection\": false\n    },\n    {\n      \"source\": \"/employeeData/(.*)\",\n      \"target\": \"/services/employeeService/$1\",\n      \"destination\": \"employeeServices\",\n      \"authenticationType\": \"xsuaa\",\n      \"scope\": [\"$XSAPPNAME.viewer\", \"$XSAPPNAME.writer\"],\n      \"csrfProtection\": true\n    },\n    {\n      \"source\": \"^/(.*)$\",\n      \"target\": \"/web/$1\",\n      \"localDir\": \"static-content\",\n      \"replace\": {\n        \"pathSuffixes\": [\"/abc/index.html\"],\n        \"vars\": [\"NAME\"]\n      }\n    }\n  ],\n  \"login\": {\n    \"callbackEndpoint\": \"/custom/login/callback\"\n  },\n  \"logout\": {\n    \"logoutEndpoint\": \"/my/logout\",\n    \"logoutPage\": \"/logout-page.html\"\n  },\n  \"destinations\": {\n    \"employeeServices\": {\n      \"logoutPath\": \"/services/employeeService/logout\",\n      \"logoutMethod\": \"GET\"\n    }\n  },\n  \"compression\": {\n    \"minSize\": 2048\n  },\n  \"whitelistService\": {\n    \"endpoint\": \"/whitelist/service\"\n  },\n  \"websockets\": {\n    \"enabled\": true\n  },\n  \"errorPage\": [\n    {\"status\": [400,401,402], \"file\": \"/custom-err-4xx.html\"},\n    {\"status\": 501, \"file\": \"/custom-err-501.html\"}\n  ]\n}\n```\n\n## Headers\n\n### Forwarding Headers\n\nThe application router passes the following x-forwarding-* headers to the destinations:\n\nHeader Name | Description\n----------- | -----------\nx-forwarded-host | Contains the *Host* header which was sent by the client to the application router.\nx-forwarded-proto | Contains the protocol which was used by the client to connect to the application router.\nx-forwarded-for | Contains the address of the client which connects to the application router.\nx-forwarded-path | Contains the original path which was requested by the client.\n\n### Hop-by-hop Headers\n\nHop-by-hop headers are meaningful only for a single transport-level connection and therefore are not forwarded by the application router.\nThese headers are:\n* Connection\n* Keep-Alive\n* Public\n* Proxy-Authenticate\n* Transfer-Encoding\n* Upgrade\n\n## CSRF Protection\n\nBy default the application router enables CSRF protection for any HTTP method that is not `HEAD` or `GET` and the route is not public.\nA path is considered _public_, if it does not require authentication. This is the case for routes with `authenticationType: none` or if authentication is disabled completely via the top level property `authenticationMethod: none`.\n\nTo obtain a CSRF token one must send a `GET` or `HEAD` request with a `x-csrf-token: fetch` header to the application router.\nThe application router will return the created token in a `x-csrf-token: <token>` header, where `<token>` will be the value of the CSRF token.\n\nIf a CSRF protected route is requested with any of the above mentioned methods,\n`x-csrf-token: <token>` header should be present in the request with the previously obtained token.\nThis request must use the same session as the fetch token request.\nIf the `x-csrf-token` header is not present or invalid, the application router will return status code *403 Forbidden*.\n\n## Web Sockets\nThe application router is capable of forwarding web socket communication.\nIn order to use the web socket communication, it should be enabled through the [application router configuration](#top-level-properties).\nIf the backend service requires authentication then the upgrade request should contain a valid session cookie.\nThe destination schemas \"ws\" and \"wss\" are supported in addition to \"http\" and \"https\".\nWhen the application router receives an upgrade request, it verifies that the `Origin` header holds the URL of the application router.\nIf this is not the case, then an HTTP response with status 403 is returned to the client.\nThis origin verification can be further configured via the environment variable `WS_ALLOWED_ORIGINS`.\nIt contains the allowed origins the application router verifies against. It's structure is the same as [`CJ_PROTECT_WHITELIST`](#configuring-allowed-hostnames--domains).\n\n**Note:** A current limitation is that a web socket ping is not forwarded to the backend service.\n\n## Session Handling\n\nThe application router establishes a session with the client (browser) using a session cookie.\n\nThe application router intercepts all _session_ cookies, sent by backend services and stores them in its own session. Backend session cookies are not sent to the client in order to prevent cookie collisions. Upon subsequent requests the application router sends back the cookies to the respective backend services so they can establish their own sessions.\n**Note:** Non-session cookies from backend services are forwarded to the client. Cookie collisions may occur and the application should be able to handle them.\n\n### Session Contents\n\n* CSRF token - the generated CSRF token so it can be verified against the token in the request, see [CSRF Protection](#csrf-protection) above.\n* OAuth token - JSON Web Token (JWT) fetched from UAA and forwarded to backend services in the Authorization header. The client never gets this token.\nThe application router refreshes the JWT automatically before it expires (if the session is valid). By default this routine is triggered 5 minutes before the expiration of the JWT.\nThis can also be configured via the `JWT_REFRESH` environment variable (the value is in minutes). If `JWT_REFRESH` is set to 0 then the refresh is disabled.\n* OAuth scopes - scopes owned by the current user, used to check if the user has the scope required for each request. See `scope` in [Routes](#routes).\n* Backend session cookies - all session cookies sent by backend services.\n\n**Note:** If the JWT is close to expiration and the session is still active a JWT refresh will be triggered in `JWT_REFRESH` minutes before expiration.\n`JWT_REFRESH` is an environment variable stating the number of minutes before the JWT expiration the refresh will be triggered. The default value is 5 minutes.\n\n## Central Logout\n\nCentral Logout can be client initiated or can be triggered due to session timeout.\n* Client initiated\n  * Deletes the user session.\n  * Requests all backend services logout paths (if configured in the [destinations property](#destinations-property)).\n  * Redirects the client to logout from UAA.\n  * If configured, redirects back to a custom page (for XS OnPremise Runtime only). For more information, see [logout-property](#logout-property).\n* Session timeout\n  * Deletes the user session.\n  * Requests all backend services logout paths (if configured in the [destinations property](#destinations-property)).\n\nThe session timeout can be configured with the [SESSION_TIMEOUT](#session-timeout) variable through the environment.\n\n## Whitelist Service\n\nWhat is it for? A protection concept is designed in SAP that uses UI libraries and whitelist service for proper clickjack protection of applications. The general idea is that when an html page needs to be rendered in a frame, a check is done by calling the whitelist service to validate if the parent frame is allowed to render the content in a frame. The actual check is provided by the whitelist service.\n\n### Enable the service\n\nTo enable the service and open the service endpoint you need to configure the [whitelistService](#whitelistservice-property) property in *xs-app.json*.\n\n### Configuring allowed hostnames / domains\n\nThe whitelist service reads allowed hostnames and domains from the environment variable `CJ_PROTECT_WHITELIST`.\nThe content is a JSON array of object with the following properties:\n\nProperty | Type | Optional | Description\n-------- | ---- |:--------:| -----------\nprotocol | String | x | URI scheme, for example `http`.\nhost | String |  | Hostname / domain - valid hostname, or domain defined with a star (\\*), for example `some.concrete.hostname`, or `*.example.domain`.\nport | String / Number | x | Port string or number containing a valid port.\n\nExample:\n```json\n[\n  {\n    \"protocol\": \"http\",\n    \"host\": \"*.example.domain\",\n    \"port\": 12345\n  },\n  {\n    \"host\": \"some.concrete.hostname\",\n  }\n]\n```\n\nMatching is done against provided properties. For example if only host is provided then the service will return `framing: true` for all and matching will be for all schemas and protocols.\n\n### Return value\n\nThe service accepts only `GET` requests and the response is a JSON object.\nThe whitelist service call uses the parent origin as URI parameter (URL encoded) as follows:\n\n```\nGET url/to/whitelist/service?parentOrigin=https://parent.domain.com\n```\n\nThe response is a JSON object with following properties:\n\n```\n{\n    \"version\" : \"1.0\",\n    \"active\"  : true | false,                   // indicates whether framing control is switched on\n    \"origin\"  : \"<same as passed to service>\",\n    \"framing\" : true | false                    // if active, describes if framing should be allowed\n}\n```\n\nThe property `active` will have value `false` only in case `CJ_PROTECT_WHITELIST` is not provided.\n\n**Note**: Keep in mind that the application router sends by default the X-Frame-Options header with value `SAMEORIGIN`, in the case whitelist service is enabled, this header value probably needs to be changed, see the [X-Frame-Options](#x-frame-options-configuration) header section for details how to change it.\n\n## Scaling\n\nThe application router keeps all established sessions in local memory and does not sync them across multiple instances.\nIn order to scale the application router to multiple instances, session stickiness should be enabled.\nThis means that each HTTP session is handled by the same application router instance.\n\nIn Cloud Foundry's router, session stickiness is enabled from version 0.1.0.\n\nIn SAP HANA XS Advanced OnPremise Runtime session stickiness is enabled, if SAP Web Dispatcher is used as a router.\nThis is set by default from version 0.1535 of SAP HANA XS Advanced runtime.\nIf your on-premise runtime uses *nginx* as router, you can switch to SAP Web Dispatcher by passing the command line option `--router=webdispatcher` to `xs-controller`.\n\n## Sizing Guide for Application Router\n\nThe memory consumption of the application router is described in the [sizing guide](doc/sizingGuide.md).\n\n## Configure server-side HTTPS\n\nYou can configure application router to accept only HTTPS connections. See `httpsOptions` option of [start](doc/extending.md#startoptions-callback) function.\n\n## Troubleshooting\n\nThe application router uses _@sap/logging_ package so all of its features are available to control logging.\nFor example to set all logging and tracing to finest level set `XS_APP_LOG_LEVEL` environment variable to `debug`.\n\nIf the application is deployed on XS Advanced On-premise Runtime, you can change the log level without restarting the application.\nFor example this command will set all logging and tracing to finest level.\n```sh\nxs set-logging-level <application-name> '*' debug\n```\nSee _@sap/logging_ documentation for details.\n\nYou can enable additional traces of the incoming and outgoing requests by setting the environment variable `REQUEST_TRACE` to `true`.\nWhen enabled they will log basic information for every incoming and outgoing request of the application router. This could have a performance impact.\n\nSome of the libraries used by this package employ other tracing mechanisms. For example many use the popular [debug](https://www.npmjs.com/package/debug) package. This means that by setting `DEBUG` environment variable, you can enable additional traces. Set it to `*` to enable all of them, but be careful as the output may be overwhelming.\nIn addition internal Node.js traces can be enabled via `NODE_DEBUG` environment variable. [This post](http://www.juliengilli.com/2013/05/26/Using-Node.js-NODE_DEBUG-for-fun-and-profit/) describes it in more detail.\n\n\n**Warning:** Enabling some of these options may trace security sensitive data, so use with caution.\n\nThe _@sap/logging_ package sets the header 'x-request-id' in the application router's responses.\nThis is useful if you would like to search entries belonging to a particular request execution in the application router's logs and traces.\nNote that the application router does not change the headers received from the backend and being forwarded to the client.\nIf the backend is a Node.js application which uses the _@sap/logging_ package (and also sets the 'x-request-id' header), then the value of the header\nthat the client will receive will be the one coming from the backend and not the one of the application router itself.\n\n## Extending Application Router\nSee [extending](doc/extending.md) for information how to extend the application router\nwith custom logic.\n\n## Best practices\n\n### Security best practices\n\n- Setting the `Content-Security-Policy` header - this is a response header which informs browsers (capable of interpreting it) about the trusted sources\nfrom which an application expects to load resources. This mechanism allows the client to detect and block malicious scripts injected into an application.\nA value can be set via the `httpHeaders` environment variable in the [additional headers configuration](#additional-headers-configuration).\nThe value represents a security policy which contains directive-value pairs. The value of a directive is a whitelist of trusted sources.\nRefer to the `Content-Security-Policy` specification for more information on the header's value.\n\n**Note**: Usage of the `Content-Security-Policy` header is considered second line of defense. An application should always provide proper input validation and output encoding.\n",
  "readmeFilename": "README.md",
  "repository": {},
  "scripts": {},
  "version": "2.7.1"
}
